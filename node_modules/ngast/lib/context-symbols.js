import { ViewEncapsulation, ɵConsole } from '@angular/core';
import { CompileMetadataResolver, NgModuleResolver, DirectiveResolver, DirectiveNormalizer, HtmlParser, CompilerConfig, PipeResolver, AotSummaryResolver, DomElementSchemaRegistry, extractProgramSymbols, StaticSymbolResolver, StaticSymbolCache, StaticReflector, createOfflineCompileUrlResolver, analyzeNgModules } from '@angular/compiler';
import { CompilerHost, NodeCompilerHostContext } from '@angular/compiler-cli';
import { PipeSymbol } from './pipe-symbol';
import { DirectiveSymbol } from './directive-symbol';
import { ModuleSymbol } from './module-symbol';
/**
 * Creates a proxy which provides us access to the symbols
 * defined in given context (could be lazy loaded module or the root module).
 *
 * @export
 * @class ContextSymbols
 */
var ContextSymbols = (function () {
    /**
     * Creates an instance of ContextSymbols.
     *
     * @param {ts.Program} program
     * @param {ResourceResolver} resourceResolver
     *
     * @memberOf ContextSymbols
     */
    function ContextSymbols(program, resourceResolver) {
        this.program = program;
        this.resourceResolver = resourceResolver;
        this.options = this.program.getCompilerOptions();
        this.init();
    }
    /**
     * Returns the metadata associated to this module.
     *
     * @returns {ModuleSymbol[]}
     *
     * @memberOf ContextSymbols
     */
    ContextSymbols.prototype.getModules = function () {
        var _this = this;
        this.validate();
        var resultMap = new Map();
        this.getAnalyzedModules()
            .ngModuleByPipeOrDirective
            .forEach(function (m, s) {
            resultMap.set(m.type.reference, m);
        });
        var result = [];
        resultMap.forEach(function (v) { return result.push(new ModuleSymbol(_this.program, v.type.reference, _this.metadataResolver, _this.directiveNormalizer, _this.directiveResolver, _this.pipeResolver, _this.reflector, _this.resourceResolver, _this)); });
        return result;
    };
    /**
     * Returns all the directives available in the context.
     *
     * @returns {DirectiveSymbol[]}
     *
     * @memberOf ContextSymbols
     */
    ContextSymbols.prototype.getDirectives = function () {
        var _this = this;
        return this.extractProgramSymbols()
            .filter(function (symbol) { return _this.metadataResolver.isDirective(symbol); })
            .map(function (symbol) { return new DirectiveSymbol(_this.program, symbol, _this.metadataResolver, _this.directiveNormalizer, _this.directiveResolver, _this.reflector, _this.resourceResolver, _this); });
    };
    /**
     * Returns all the pipes available in this module.
     *
     * @returns {PipeSymbol[]}
     *
     * @memberOf ContextSymbols
     */
    ContextSymbols.prototype.getPipes = function () {
        var _this = this;
        return this.extractProgramSymbols()
            .filter(function (v) { return _this.metadataResolver.isPipe(v); })
            .map(function (p) { return new PipeSymbol(_this.program, p, _this.pipeResolver, _this.metadataResolver, _this); });
    };
    /**
     * Returns the summary of this context.
     *
     * @returns {(CompileNgModuleSummary | undefined)}
     *
     * @memberOf ContextSymbols
     */
    ContextSymbols.prototype.getContextSummary = function () {
        var module = this.getModules().pop();
        if (module) {
            return this.metadataResolver.getNgModuleSummary(module.symbol);
        }
        return undefined;
    };
    /**
     * Updates the program which has impact over the loaded symbols.
     * In case the `udpate` method is called with program different from
     * the current one, all the internal caches will be cleared.
     *
     * @param {ts.Program} program
     *
     * @memberOf ContextSymbols
     */
    ContextSymbols.prototype.updateProgram = function (program) {
        if (program !== this.program) {
            this.program = program;
            this.validate();
        }
    };
    /**
     * Returns directive based on `ClassDeclaration` node and a filename.
     *
     * @param {ts.ClassDeclaration} declaration
     * @param {string} fileName
     *
     * @memberOf DirectiveSymbol
     */
    ContextSymbols.prototype.getDirectiveFromNode = function (declaration, fileName) {
        var sourceFile = this.program.getSourceFile(fileName);
        return new DirectiveSymbol(this.program, this.reflector.getStaticSymbol(sourceFile.fileName, declaration.name.text), this.metadataResolver, this.directiveNormalizer, this.directiveResolver, this.reflector, this.resourceResolver, this);
    };
    /** @internal */
    ContextSymbols.prototype.getAnalyzedModules = function () {
        var analyzedModules = this.analyzedModules;
        if (!analyzedModules) {
            var analyzeHost = { isSourceFile: function (filePath) { return true; } };
            var programSymbols = extractProgramSymbols(this.staticSymbolResolver, this.program.getSourceFiles().map(function (sf) { return sf.fileName; }), analyzeHost);
            analyzedModules = this.analyzedModules =
                analyzeNgModules(programSymbols, analyzeHost, this.metadataResolver);
        }
        return analyzedModules;
    };
    ContextSymbols.prototype.extractProgramSymbols = function () {
        return extractProgramSymbols(this.staticSymbolResolver, this.program.getSourceFiles().map(function (sf) { return sf.fileName; }), {
            isSourceFile: function () { return true; }
        });
    };
    ContextSymbols.prototype.validate = function () {
        var program = this.program;
        if (this.lastProgram !== program) {
            this.clearCaches();
            this.lastProgram = program;
            this.init();
        }
    };
    ContextSymbols.prototype.clearCaches = function () {
        this.metadataResolver.clearCache();
        this.directiveNormalizer.clearCache();
    };
    ContextSymbols.prototype.init = function () {
        var staticSymbolCache = new StaticSymbolCache();
        var summaryResolver = new AotSummaryResolver({
            loadSummary: function (filePath) { return ''; },
            isSourceFile: function (sourceFilePath) { return true; },
            getOutputFileName: function () { return ''; }
        }, staticSymbolCache);
        var parser = new HtmlParser();
        var config = new CompilerConfig({
            defaultEncapsulation: ViewEncapsulation.Emulated,
            useJit: false
        });
        var defaultDir = this.program.getCurrentDirectory();
        this.options.baseUrl = this.options.baseUrl || defaultDir;
        this.options.basePath = this.options.basePath || defaultDir;
        this.options.genDir = this.options.genDir || defaultDir;
        this.staticResolverHost = new CompilerHost(this.program, this.options, new NodeCompilerHostContext());
        this.staticSymbolResolver = new StaticSymbolResolver(
        // The strict null check gets confused here
        this.staticResolverHost, staticSymbolCache, summaryResolver, function (e, filePath) {
            console.log(e, filePath);
        });
        this.reflector = new StaticReflector(this.staticSymbolResolver, [], [], function (e, filePath) {
            console.log(e, filePath);
        });
        var ngModuleResolver = new NgModuleResolver(this.reflector);
        this.directiveResolver = new DirectiveResolver(this.reflector);
        this.pipeResolver = new PipeResolver(this.reflector);
        this.urlResolver = createOfflineCompileUrlResolver();
        this.directiveNormalizer = new DirectiveNormalizer(this.resourceResolver, this.urlResolver, parser, config);
        this.metadataResolver = new CompileMetadataResolver(new CompilerConfig(), ngModuleResolver, this.directiveResolver, this.pipeResolver, summaryResolver, new DomElementSchemaRegistry(), this.directiveNormalizer, new ɵConsole(), new StaticSymbolCache(), this.reflector);
    };
    return ContextSymbols;
}());
export { ContextSymbols };
//# sourceMappingURL=context-symbols.js.map