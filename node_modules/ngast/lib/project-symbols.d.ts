import { Program } from 'typescript';
import { ContextSymbols } from './context-symbols';
import { ResourceResolver } from './resource-resolver';
/**
 * Interface used for type checking routes gotten from the summary.
 *
 * @export
 * @interface Route
 */
export interface Route {
    path: string;
    loadChildren?: string;
    component?: any;
}
/**
 * Classes implementing this interface should define logic
 * which is responsible for getting the URL to a lazy module.
 * The most primitive `LazyModuleResolver` will simply take the content
 * of the property `loadChildren`. More advanced implementation
 * may parse `System` calls.
 *
 * @export
 * @interface LazyModuleResolver
 */
export interface LazyModuleResolver {
    /**
     * Based on the path of the file containing the route routeDefinition
     * and the route definition itself, this method should return the
     * path of the lazy loaded module.
     *
     * @param {string} basePath
     * @param {Route} routeDefinition
     * @returns {(string | undefined)}
     *
     * @memberOf LazyModuleResolver
     */
    resolve(basePath: string, routeDefinition: Route): string | undefined;
}
/**
 * Implementation of the `LazyModuleResolver` which resolves
 * lazy module URL or path in cases when `loadChildren` has a string value.
 *
 * @export
 * @class BasicLazyModuleResolver
 * @implements {LazyModuleResolver}
 */
export declare class BasicLazyModuleResolver implements LazyModuleResolver {
    private resolver;
    /**
     * Returns URL or path to given lazy loaded module.
     *
     * @param {string} basePath
     * @param {Route} routeDefinition
     * @returns
     *
     * @memberOf BasicLazyModuleResolver
     */
    resolve(basePath: string, routeDefinition: Route): string;
}
/**
 * Classes which implement this interface should be able
 * to create a `ts.Program` based on passed files as arguments.
 *
 * @export
 * @interface ProgramFactory
 */
export interface ProgramFactory {
    /**
     * Creates a `ts.Program` based on some files passed as argument.
     * Usually this method will use external `tsconfig.json` and either
     * override or alter the set of files defined there.
     *
     * @param {string[]} [files]
     * @returns {Program}
     *
     * @memberOf ProgramFactory
     */
    create(files?: string[]): Program;
}
/**
 * This class is a wrapper around an Angular project.
 * It provides access to the root module of the project as well
 * as to it's lazy loaded modules which can be resolved.
 *
 * @export
 * @class ProjectSymbols
 */
export declare class ProjectSymbols {
    private programFactory;
    private resolver;
    private lazyModuleResolver;
    private rootContext;
    /**
     * Creates an instance of ProjectSymbols.
     *
     * @param {ProgramFactory} programFactory
     * @param {ResourceResolver} resolver
     * @param {any} [lazyModuleResolver=new BasicLazyModuleResolver()]
     *
     * @memberOf ProjectSymbols
     */
    constructor(programFactory: ProgramFactory, resolver: ResourceResolver, lazyModuleResolver?: BasicLazyModuleResolver);
    /**
     * Provides access to the `ContextSymbols` corresponding
     * to the root module of the project that is not loaded lazily.
     *
     * @returns {ContextSymbols}
     *
     * @memberOf ProjectSymbols
     */
    getRootContext(): ContextSymbols;
    /**
     * Returns a list of all modules in the project:
     * - All lazy loaded modules
     * - The root module
     *
     * @returns {ContextSymbols[]}
     *
     * @memberOf ProjectSymbols
     */
    getLazyLoadedContexts(): ContextSymbols[];
}
