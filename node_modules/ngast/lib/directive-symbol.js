var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { resolveForwardRef } from '@angular/core';
import { componentModuleUrl, UrlResolver, HtmlParser, I18NHtmlParser, Lexer, Parser, TemplateParser, DomElementSchemaRegistry, CompilerConfig } from '@angular/compiler';
import { Symbol } from './symbol';
import { parseCss } from './css-parser/parse-css';
import { ProviderSymbol } from './provider-symbol';
import { ProviderMeta } from '@angular/compiler';
/**
 * This class represents the individual directives and wrapps
 * their `StaticSymbol`s produced by the `@angular/compiler`.
 *
 * @export
 * @class DirectiveSymbol
 * @extends {Symbol}
 */
var DirectiveSymbol = (function (_super) {
    __extends(DirectiveSymbol, _super);
    /**
     * Creates an instance of DirectiveSymbol.
     *
     * @param {Program} program
     * @param {StaticSymbol} symbol
     * @param {CompileMetadataResolver} metadataResolver
     * @param {DirectiveNormalizer} directiveNormalizer
     * @param {DirectiveResolver} resolver
     * @param {StaticReflector} reflector
     * @param {ResourceResolver} resourceResolver
     * @param {ContextSymbols} projectSymbols
     *
     * @memberOf DirectiveSymbol
     */
    function DirectiveSymbol(program, symbol, metadataResolver, directiveNormalizer, resolver, reflector, resourceResolver, projectSymbols) {
        var _this = _super.call(this, program, symbol) || this;
        _this.metadataResolver = metadataResolver;
        _this.directiveNormalizer = directiveNormalizer;
        _this.resolver = resolver;
        _this.reflector = reflector;
        _this.resourceResolver = resourceResolver;
        _this.projectSymbols = projectSymbols;
        _this.urlResolver = new UrlResolver();
        return _this;
    }
    /**
     * Returns the non-resolved metadata for given directive.
     * If it is a component, this means that the external templates
     * and styles won't be read from the drive. Also, the paths to
     * external metadata won't be resolved.
     *
     * @returns {CompileDirectiveMetadata}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getNonResolvedMetadata = function () {
        return this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol).metadata;
    };
    // TODO: use the normalizer's cache in order to prevent repetative I/O operations
    /**
     * Returns the normalized and resolved metadata for given directive or component.
     * For components, all the external templates and styles will be read and
     * set as values of the returned `CompileTemplateMetadata` properties.
     *
     * @returns {CompileTemplateMetadata}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getResolvedMetadata = function () {
        var _this = this;
        var metadata = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
        var componentType = resolveForwardRef(this.symbol);
        var componentUrl = componentModuleUrl(this.reflector, componentType, metadata);
        var templateMetadata = metadata.metadata.template;
        // Required because otherwise the normalizer gets confused.
        if (!templateMetadata.template) {
            templateMetadata.templateUrl = this.urlResolver.resolve(componentUrl, templateMetadata.templateUrl);
            templateMetadata.template = this.resourceResolver.getSync(templateMetadata.templateUrl);
        }
        var currentMetadata = this.directiveNormalizer.normalizeTemplateSync(Object.assign(templateMetadata, {
            ngModuleType: this.getModule().type.reference,
            moduleUrl: componentUrl,
            componentType: componentType
        }));
        if (templateMetadata.templateUrl) {
            currentMetadata.template = this.resourceResolver.getSync(templateMetadata.templateUrl);
            currentMetadata.templateUrl = templateMetadata.templateUrl;
        }
        currentMetadata.styles = currentMetadata.styles.concat(currentMetadata.styleUrls.map(function (path) {
            return _this.resourceResolver.getSync(path);
        }));
        return currentMetadata;
    };
    /**
     * Returns the module where the given directive has been declared.
     *
     * @returns {(CompileNgModuleMetadata | undefined)}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getModule = function () {
        return this.projectSymbols
            .getAnalyzedModules().ngModuleByPipeOrDirective.get(this.symbol);
    };
    /**
     * Returns the ASTs of all styles of the target directive.
     *
     * @returns {CssAst[]}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getStyleAsts = function () {
        return this.getResolvedMetadata()
            .styles.map(function (s) { return parseCss(s); });
    };
    /**
     * Returns the context into which the template of given
     * component is going to be compiled.
     *
     * @returns {DirectiveContext}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getDirectiveContext = function () {
        var _this = this;
        var analyzedModules = this.projectSymbols.getAnalyzedModules();
        var ngModule = analyzedModules.ngModuleByPipeOrDirective.get(this.symbol);
        if (!ngModule) {
            throw new Error('Cannot find module associated with the directive ' + this.symbol.name);
        }
        var resolvedDirectives = ngModule.transitiveModule.directives.map(function (d) { return _this.metadataResolver.getNonNormalizedDirectiveMetadata(d.reference); });
        var directives = resolvedDirectives.filter(function (d) { return d !== null; }).map(function (d) { return d.metadata.toSummary(); });
        var pipes = ngModule.transitiveModule.pipes.map(function (p) { return _this.metadataResolver.getOrLoadPipeMetadata(p.reference).toSummary(); });
        var schemas = ngModule.schemas;
        return {
            pipes: pipes, directives: directives, schemas: schemas
        };
    };
    /**
     * Returns the compiled template of the target component.
     *
     * @returns {TemplateAstResult}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getTemplateAst = function () {
        var result;
        try {
            var resolvedMetadata = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
            var dirMetadata = this.getResolvedMetadata();
            var source = dirMetadata.template;
            var metadata = resolvedMetadata && resolvedMetadata.metadata;
            if (metadata) {
                var rawHtmlParser = new HtmlParser();
                var htmlParser = new I18NHtmlParser(rawHtmlParser);
                var expressionParser = new Parser(new Lexer());
                var parser = void 0;
                parser = new TemplateParser(new CompilerConfig, expressionParser, new DomElementSchemaRegistry(), htmlParser, undefined, []);
                var htmlResult = htmlParser.parse(source, '');
                var _a = this.getDirectiveContext(), directives = _a.directives, pipes = _a.pipes, schemas = _a.schemas;
                var parseResult = parser.tryParseHtml(htmlResult, metadata, source, directives, pipes, schemas, '');
                result = {
                    templateAst: parseResult.templateAst,
                    parseErrors: parseResult.errors,
                    errors: []
                };
            }
            else {
                result = { errors: [{ message: 'Cannot find metadata for the directive' }] };
            }
        }
        catch (e) {
            result = { errors: [{ message: e.message }] };
        }
        return result;
    };
    DirectiveSymbol.prototype.getDependencies = function () {
        var _this = this;
        var summary = this.metadataResolver.getInjectableSummary(this.symbol);
        if (!summary) {
            return [];
        }
        else {
            return (summary.type.diDeps || []).map(function (d) {
                var meta = new ProviderMeta(d.token.identifier.reference, d);
                return new ProviderSymbol(_this._program, _this.metadataResolver.getProviderMetadata(meta), _this.metadataResolver);
            });
        }
    };
    // getProviders() {
    //   return (this.getNonResolvedMetadata().providers || []).map(d => {
    //     const meta = new ProviderMeta(d.token.identifier.reference, d);
    //     return new ProviderSymbol(
    //       this._program,
    //       this.metadataResolver.getProviderMetadata(meta),
    //       this.metadataResolver
    //     );
    //   });
    // }
    // getViewProviders() {
    //   return (this.getNonResolvedMetadata().viewProviders || []).map(d => {
    //     const meta = new ProviderMeta(d.token.identifier.reference, d);
    //     return new ProviderSymbol(
    //       this._program,
    //       this.metadataResolver.getProviderMetadata(meta),
    //       this.metadataResolver
    //     );
    //   });
    // }
    /**
     * Returns if the target directive is a component.
     *
     * @returns {boolean}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.isComponent = function () {
        return !!this.getResolvedMetadata().template;
    };
    return DirectiveSymbol;
}(Symbol));
export { DirectiveSymbol };
//# sourceMappingURL=directive-symbol.js.map