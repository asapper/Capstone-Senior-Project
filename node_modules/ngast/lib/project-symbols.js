import { UrlResolver } from '@angular/compiler';
import { ContextSymbols } from './context-symbols';
/**
 * Implementation of the `LazyModuleResolver` which resolves
 * lazy module URL or path in cases when `loadChildren` has a string value.
 *
 * @export
 * @class BasicLazyModuleResolver
 * @implements {LazyModuleResolver}
 */
var BasicLazyModuleResolver = (function () {
    function BasicLazyModuleResolver() {
        this.resolver = new UrlResolver();
    }
    /**
     * Returns URL or path to given lazy loaded module.
     *
     * @param {string} basePath
     * @param {Route} routeDefinition
     * @returns
     *
     * @memberOf BasicLazyModuleResolver
     */
    BasicLazyModuleResolver.prototype.resolve = function (basePath, routeDefinition) {
        if (typeof routeDefinition.loadChildren === 'string') {
            return this.resolver.resolve(basePath, (routeDefinition.loadChildren.split('#').shift() || '') + '.ts');
        }
        return undefined;
    };
    return BasicLazyModuleResolver;
}());
export { BasicLazyModuleResolver };
/**
 * This class is a wrapper around an Angular project.
 * It provides access to the root module of the project as well
 * as to it's lazy loaded modules which can be resolved.
 *
 * @export
 * @class ProjectSymbols
 */
var ProjectSymbols = (function () {
    /**
     * Creates an instance of ProjectSymbols.
     *
     * @param {ProgramFactory} programFactory
     * @param {ResourceResolver} resolver
     * @param {any} [lazyModuleResolver=new BasicLazyModuleResolver()]
     *
     * @memberOf ProjectSymbols
     */
    function ProjectSymbols(programFactory, resolver, lazyModuleResolver) {
        if (lazyModuleResolver === void 0) { lazyModuleResolver = new BasicLazyModuleResolver(); }
        this.programFactory = programFactory;
        this.resolver = resolver;
        this.lazyModuleResolver = lazyModuleResolver;
    }
    /**
     * Provides access to the `ContextSymbols` corresponding
     * to the root module of the project that is not loaded lazily.
     *
     * @returns {ContextSymbols}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getRootContext = function () {
        if (this.rootContext) {
            return this.rootContext;
        }
        var program = this.programFactory.create();
        this.rootContext = new ContextSymbols(program, this.resolver);
        return this.rootContext;
    };
    /**
     * Returns a list of all modules in the project:
     * - All lazy loaded modules
     * - The root module
     *
     * @returns {ContextSymbols[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getLazyLoadedContexts = function () {
        var _this = this;
        if (!this.rootContext) {
            this.getRootContext();
        }
        var summary = this.rootContext.getContextSummary();
        // If struggles with performance make it more imperative
        var discoverModules = function (summary) {
            if (!summary || !summary.type || !summary.type.reference)
                return [];
            var routes = summary.providers
                .filter(function (p) { return 'ANALYZE_FOR_ENTRY_COMPONENTS' === p.provider.token.identifier.reference.name; })
                .map(function (p) { return p.provider.useValue; });
            var contexts = [].concat.apply([], routes)
                .filter(function (r) { return !!r.loadChildren; })
                .map(function (r) { return _this.lazyModuleResolver.resolve(summary.type.reference.filePath, r); })
                .filter(function (r) { return !!r; })
                .map(function (p) { return new ContextSymbols(_this.programFactory.create([p]), _this.resolver); });
            return contexts.concat([].concat.apply([], contexts.map(function (c) { return c.getContextSummary(); }).map(discoverModules)));
        };
        return [this.rootContext].concat(discoverModules(summary));
    };
    return ProjectSymbols;
}());
export { ProjectSymbols };
//# sourceMappingURL=project-symbols.js.map